//+------------------------------------------------------------------+
//|                                                     FibStoch.mq5 |
//|                                  Copyright 2024, Jules Engineer |
//|                                                                  |
//+------------------------------------------------------------------+
#property copyright "Copyright 2024, Jules Engineer"
#property link      "https://www.mql5.com"
#property version   "2.00"
#property indicator_separate_window
#property indicator_buffers 38
#property indicator_plots   19

#property indicator_level1 20
#property indicator_level2 50
#property indicator_level3 80

//--- Calculation type
enum ENUM_CALC_TYPE
  {
   CALC_NORMAL,   // Normal
   CALC_SUM,      // Sum
   CALC_DIV,      // Difference
   CALC_SIGN,     // Sign
   CALC_DIV_SUM,  // Sum of differences
   CALC_MULT      // Multiplication
  };

//--- Summation type
enum ENUM_SUM_TYPE
  {
   SUM_FORWARD,  // Forward summation (from current to end)
   SUM_BACKWARD  // Backward summation (from start to current)
  };

//--- Stochastic line type
enum ENUM_KD_TYPE
  {
   KD_MAIN,   // Main line (%K)
   KD_SIGNAL  // Signal line (%D)
  };

//--- Moving Average method
enum ENUM_CUSTOM_MA_METHOD
  {
   MODE_SMA,    // Simple Moving Average
   MODE_EMA,    // Exponential Moving Average
   MODE_SMMA,   // Smoothed Moving Average
   MODE_LWMA,   // Linear Weighted Moving Average
   MODE_HMA,    // Hull Moving Average
   MODE_ZLEMA   // Zero-Lag Exponential Moving Average
  };

//--- input parameters
input int             DisplayStart = 0;
input int             DisplayEnd = 18;
input int             BuffNum=19;
input ENUM_CALC_TYPE  CalcType=CALC_NORMAL;
input ENUM_SUM_TYPE   SumType=SUM_FORWARD;
input ENUM_KD_TYPE    KDType=KD_SIGNAL;
input int             Slowing=1;
input ENUM_CUSTOM_MA_METHOD MA_Method=MODE_SMA;
input ENUM_STO_PRICE Price_field=STO_LOWHIGH; // Note: Custom MA implementation currently uses Close price for %K calculation.

//--- indicator buffers
struct Plot
{
   double PlotBuffer[];
};
Plot PlotList[];

input uint HighLevel=80;
input uint LowLevel=20;

struct Stoch
{
   int KPeriod;
   int DPeriod;
   int Slowing;
   double   StochBuffer[];
   int Handle;
   int Calculated;
   double Coeff;
};

struct StochList
{
   Stoch Stoch;
};
StochList FibStochList[];

int Fibonacci[] = {1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765};

#define RESET 0

// Forward declarations for helper functions
void HMA(const int rates_total, const int period, const double price[], double buffer[]);
void ZLEMA(const int rates_total, const int period, const double price[], double buffer[]);
void CustomStochastic(int k_period, int d_period, int slowing, ENUM_CUSTOM_MA_METHOD ma_method,
                      const int rates_total, const double high[], const double low[], const double close[],
                      double k_buffer[], double d_buffer[]);
int CalcPlotBufferNormal(int index, int bar, int limit, double plotBuffer[], StochList stochList[]);
int CalcPlotBufferSum(int index, int bar, int limit, double plotBuffer[], StochList stochList[]);
int CalcPlotBufferDiv(int index, int bar, int limit, double plotBuffer[], StochList stochList[]);
int CalcPlotBufferSign(int index, int bar, int limit, double plotBuffer[], StochList stochList[]);
int CalcPlotBufferDivSum(int index, int bar, int limit, double plotBuffer[], StochList stochList[]);
int CalcPlotBufferMult(int index, int bar, int limit, double plotBuffer[], StochList stochList[]);

//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
int OnInit()
  {
   if(BuffNum > 19) BuffNum = 19;
   ArrayResize(FibStochList, BuffNum);
   ArrayResize(PlotList, BuffNum);

   IndicatorSetString(INDICATOR_SHORTNAME, "FibStoch Refactored");

   for(int i = 0; i < BuffNum; i++)
     {
      // Set plot buffer
      SetIndexBuffer(i, PlotList[i].PlotBuffer, INDICATOR_DATA);
      ArraySetAsSeries(PlotList[i].PlotBuffer, true);

      // Set plot label
      PlotIndexSetString(i, PLOT_LABEL, "P" + (string)(i + 1));

      // Dynamic visibility
      if(i < DisplayStart || i > DisplayEnd)
        {
         PlotIndexSetInteger(i, PLOT_DRAW_TYPE, DRAW_NONE);
         continue;
        }

      PlotIndexSetInteger(i, PLOT_DRAW_TYPE, DRAW_LINE);

      // Grouped styling
      int width = 1;
      color clr;
      ENUM_LINE_STYLE style;

      if(i < 6) // Group 1: Short-term (Fib 1-13)
        {
         clr = (color)ColorToARGB(C'200,200,255') - i * 0x00202000; // Blue gradient
         style = STYLE_SOLID;
        }
      else if(i < 11) // Group 2: Mid-term (Fib 21-144)
        {
         clr = (color)ColorToARGB(C'200,255,200') - (i - 6) * 0x00200020; // Green gradient
         style = STYLE_DASH;
        }
      else // Group 3: Long-term (Fib 233+)
        {
         clr = (color)ColorToARGB(C'255,200,200') - (i - 11) * 0x00002020; // Red gradient
         style = STYLE_DOT;
        }

      // Emphasize important lines P6(21), P7(34), P11(144)
      if(i == 6 || i == 7 || i == 10)
        {
         width = 2;
        }

      PlotIndexSetInteger(i, PLOT_LINE_COLOR, clr);
      PlotIndexSetInteger(i, PLOT_LINE_STYLE, style);
      PlotIndexSetInteger(i, PLOT_LINE_WIDTH, width);
     }

   for(int i = 0; i < BuffNum; i++)
     {
      FibStochList[i].Stoch.KPeriod = Fibonacci[i];
      FibStochList[i].Stoch.DPeriod = Fibonacci[i];
      FibStochList[i].Stoch.Slowing = Slowing;
      FibStochList[i].Stoch.Coeff = Fibonacci[i];
      // Setup calculation buffers
      SetIndexBuffer(BuffNum + i, FibStochList[i].Stoch.StochBuffer, INDICATOR_CALCULATIONS);
      ArraySetAsSeries(FibStochList[i].Stoch.StochBuffer, true);

      if(MA_Method != MODE_HMA && MA_Method != MODE_ZLEMA)
        {
         FibStochList[i].Stoch.Handle = iStochastic(Symbol(), Period(), Fibonacci[i], Fibonacci[i], Slowing, (ENUM_MA_METHOD)MA_Method, Price_field);
        }
      else
        {
         FibStochList[i].Stoch.Handle = -1; // Custom calculation will be used
        }
     }

   IndicatorSetDouble(INDICATOR_LEVELVALUE, 0, HighLevel);
   IndicatorSetDouble(INDICATOR_LEVELVALUE, 1, 50);
   IndicatorSetDouble(INDICATOR_LEVELVALUE, 2, LowLevel);

   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//| Custom indicator iteration function                              |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const int begin,
                const double &price[])
  {
   int bars_to_process = rates_total - prev_calculated;
   if(prev_calculated == 0) bars_to_process = rates_total;

   //--- For Custom MAs, pre-fetch all price data once
   double high[], low[], close[];
   if(MA_Method == MODE_HMA || MA_Method == MODE_ZLEMA)
     {
      if(CopyHigh(Symbol(), Period(), 0, rates_total, high) <= 0) return(RESET);
      if(CopyLow(Symbol(), Period(), 0, rates_total, low) <= 0) return(RESET);
      if(CopyClose(Symbol(), Period(), 0, rates_total, close) <= 0) return(RESET);
     }

   //--- Loop to fill StochBuffer for each period
   for(int i = 0; i < BuffNum; i++)
     {
      if(MA_Method == MODE_HMA || MA_Method == MODE_ZLEMA)
        {
         double k_buffer[], d_buffer[];
         ArrayResize(k_buffer, rates_total);
         ArrayResize(d_buffer, rates_total);

         CustomStochastic(FibStochList[i].Stoch.KPeriod, FibStochList[i].Stoch.DPeriod, FibStochList[i].Stoch.Slowing,
                          MA_Method, rates_total, high, low, close, k_buffer, d_buffer);

         if(KDType == KD_MAIN)
            ArrayCopy(FibStochList[i].Stoch.StochBuffer, k_buffer, 0, 0, WHOLE_ARRAY);
         else
            ArrayCopy(FibStochList[i].Stoch.StochBuffer, d_buffer, 0, 0, WHOLE_ARRAY);
        }
      else // Standard MAs
        {
         if(FibStochList[i].Stoch.Handle < 0 || BarsCalculated(FibStochList[i].Stoch.Handle) < rates_total) continue; // Skip if handle is bad

         int line_type = (KDType == KD_MAIN) ? MAIN_LINE : SIGNAL_LINE;

         if(CopyBuffer(FibStochList[i].Stoch.Handle, line_type, 0, rates_total, FibStochList[i].Stoch.StochBuffer) <= 0)
            continue; // Don't reset everything, just skip this buffer
        }
     }

   //--- Final calculation loop for visible plot buffers
   int limit = rates_total - 1;
   if(prev_calculated > 0) limit = bars_to_process + 1;

   for(int bar = limit; bar >= 0 && !IsStopped(); bar--)
     {
      for(int i = 0; i < BuffNum; i++)
        {
         // Skip calculation for invisible plots
         if(i < DisplayStart || i > DisplayEnd) continue;

         switch(CalcType)
           {
            case CALC_NORMAL:
               CalcPlotBufferNormal(i, bar, rates_total, PlotList[i].PlotBuffer, FibStochList);
               break;
            case CALC_SUM:
               CalcPlotBufferSum(i, bar, rates_total, PlotList[i].PlotBuffer, FibStochList);
               break;
            case CALC_DIV:
               CalcPlotBufferDiv(i, bar, rates_total, PlotList[i].PlotBuffer, FibStochList);
               break;
            case CALC_SIGN:
               CalcPlotBufferSign(i, bar, rates_total, PlotList[i].PlotBuffer, FibStochList);
               break;
            case CALC_DIV_SUM:
               CalcPlotBufferDivSum(i, bar, rates_total, PlotList[i].PlotBuffer, FibStochList);
               break;
            case CALC_MULT:
               CalcPlotBufferMult(i, bar, rates_total, PlotList[i].PlotBuffer, FibStochList);
               break;
            default:
               break;
           }
        }
     }
   return(rates_total);
  }

//+------------------------------------------------------------------+
//| Calculation Helper Functions                                     |
//+------------------------------------------------------------------+
int CalcPlotBufferNormal(int index, int bar, int limit, double plotBuffer[], StochList stochList[])
  {
   double val = stochList[index].Stoch.StochBuffer[bar];
   plotBuffer[bar] = (val < 100 && val > 0) ? val : 0.0;
   return(0);
  }

int CalcPlotBufferSum(int index, int bar, int limit, double plotBuffer[], StochList stochList[])
  {
   double val = 0.0;
   double w_sum = 0.0;
   if(SumType == SUM_FORWARD)
     {
      for(int i = index; i < BuffNum; i++)
        {
         double stoch_val = stochList[i].Stoch.StochBuffer[bar];
         if(stoch_val < 100 && stoch_val > 0)
           {
            val += stoch_val;
            w_sum += 1.0;
           }
        }
     }
   else // SUM_BACKWARD
     {
      for(int i = 0; i <= index; i++)
        {
         double stoch_val = stochList[i].Stoch.StochBuffer[bar];
         if(stoch_val < 100 && stoch_val > 0)
           {
            val += stoch_val;
            w_sum += 1.0;
           }
        }
     }
   plotBuffer[bar] = (w_sum != 0) ? val / w_sum : 0.0;
   return(0);
  }

int CalcPlotBufferDiv(int index, int bar, int limit, double plotBuffer[], StochList stochList[])
  {
   if(bar < limit - 1)
     {
      plotBuffer[bar] = stochList[index].Stoch.StochBuffer[bar] - stochList[index].Stoch.StochBuffer[bar + 1];
     }
   else
     {
      plotBuffer[bar] = 0.0;
     }
   return(0);
  }

int CalcPlotBufferSign(int index, int bar, int limit, double plotBuffer[], StochList stochList[])
  {
   if(bar < limit - 1)
     {
      double stoch_val = stochList[index].Stoch.StochBuffer[bar];
      if(stoch_val < 100 && stoch_val > 0)
        {
         plotBuffer[bar] = ((stoch_val - stochList[index].Stoch.StochBuffer[bar + 1]) > 0) ? 1 : -1;
        }
     }
   else
     {
      plotBuffer[bar] = 0.0;
     }
   return(0);
  }

int CalcPlotBufferDivSum(int index, int bar, int limit, double plotBuffer[], StochList stochList[])
  {
   double val = 0.0;
   if(bar < limit - 1)
     {
      for(int i = index; i < BuffNum; i++)
        {
         val += stochList[i].Stoch.StochBuffer[bar] - stochList[i].Stoch.StochBuffer[bar + 1];
        }
     }
   plotBuffer[bar] = val / (BuffNum - index);
   return(0);
  }

int CalcPlotBufferMult(int index, int bar, int limit, double plotBuffer[], StochList stochList[])
  {
   double val = 1.0;
   for(int i = index; i < BuffNum; i++)
     {
      double stoch_val = stochList[i].Stoch.StochBuffer[bar];
      if(stoch_val > 0 && stoch_val < 100)
        {
         val *= stoch_val / 50.0;
        }
     }
   plotBuffer[bar] = MathLog10(val);
   return(0);
  }

//+------------------------------------------------------------------+
//| Custom MA and Stochastic Implementations                         |
//+------------------------------------------------------------------+
void HMA(const int rates_total, const int period, const double price[], double buffer[])
  {
   if(period <= 1) { ArrayInitialize(buffer, 0); return; }

   int hma_period = (int)MathSqrt(period);
   double lwma1[], lwma2[], hma_raw[];
   ArrayResize(lwma1, rates_total);
   ArrayResize(lwma2, rates_total);
   ArrayResize(hma_raw, rates_total);

   iMAOnArray(price, 0, period / 2, 0, MODE_LWMA, lwma1);
   iMAOnArray(price, 0, period, 0, MODE_LWMA, lwma2);

   for(int i = 0; i < rates_total; i++)
     {
      hma_raw[i] = 2.0 * lwma1[i] - lwma2[i];
     }
   iMAOnArray(hma_raw, 0, hma_period, 0, MODE_LWMA, buffer);
  }

void ZLEMA(const int rates_total, const int period, const double price[], double buffer[])
  {
   if(period <= 0) { ArrayInitialize(buffer, 0); return; }

   double ema[];
   ArrayResize(ema, rates_total);
   int lag = (period - 1) / 2;

   iMAOnArray(price, 0, period, 0, MODE_EMA, ema);

   for(int i = 0; i < rates_total - lag; i++)
     {
      buffer[i] = ema[i] + (price[i] - ema[i+lag]);
     }
  }

void CustomStochastic(int k_period, int d_period, int slowing, ENUM_CUSTOM_MA_METHOD ma_method,
                      const int rates_total, const double high[], const double low[], const double close[],
                      double k_buffer[], double d_buffer[])
  {
   if(k_period <= 0 || d_period <= 0 || slowing <= 0) return;

   double hh_buffer[], ll_buffer[], stoch_val[];
   ArrayResize(hh_buffer, rates_total);
   ArrayResize(ll_buffer, rates_total);
   ArrayResize(stoch_val, rates_total);

   for(int i = 0; i < rates_total - k_period; i++)
     {
      int hh_idx = ArrayMaximum(high, i, k_period);
      int ll_idx = ArrayMinimum(low, i, k_period);
      hh_buffer[i] = high[hh_idx];
      ll_buffer[i] = low[ll_idx];

      double den = hh_buffer[i] - ll_buffer[i];
      if(den != 0)
         stoch_val[i] = 100 * (close[i] - ll_buffer[i]) / den;
      else
         stoch_val[i] = 0;
     }

   if(slowing > 1)
     {
      iMAOnArray(stoch_val, 0, slowing, 0, MODE_SMA, k_buffer);
     }
   else
     {
      ArrayCopy(k_buffer, stoch_val);
     }

   if(ma_method == MODE_HMA)
      HMA(rates_total, d_period, k_buffer, d_buffer);
   else if(ma_method == MODE_ZLEMA)
      ZLEMA(rates_total, d_period, k_buffer, d_buffer);
   else
      iMAOnArray(k_buffer, 0, d_period, 0, (ENUM_MA_METHOD)ma_method, d_buffer);
  }
//+------------------------------------------------------------------+