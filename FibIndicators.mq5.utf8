//+------------------------------------------------------------------+
//|                                     FibIndicators_Refactored.mq5 |
//|                         Copyright 2024, MetaQuotes Software Corp. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2024, MetaQuotes Software Corp."
#property link      "https://www.mql5.com"
#property version   "2.0"
#property description "Refactored Fibonacci Stochastic Indicator"

#property indicator_separate_window
#property indicator_buffers 38 // 19 for plotting, 19 for calculations
#property indicator_plots   19

#property indicator_level1 20.0
#property indicator_level2 50.0
#property indicator_level3 80.0
#property indicator_levelcolor clrGray
#property indicator_levelstyle STYLE_DOT

//--- Enums for User Inputs
enum ENUM_CALC_TYPE
  {
   CALC_NORMAL,    // Normal Stochastic Value
   CALC_SUM,       // Sum of Stochastic Values
   CALC_DIV,       // Difference
   CALC_SIGN,      // Sign of Change
   CALC_DIV_SUM,   // Sum of Differences
   CALC_MULT       // Multiplied Value
  };

enum ENUM_SUM_TYPE
  {
   SUM_FORWARD,    // Sum from current index to the end
   SUM_BACKWARD    // Sum from the beginning to the current index
  };

enum ENUM_KD_TYPE
  {
   KD_MAIN,        // Use %K line for calculations
   KD_SIGNAL       // Use %D line for calculations
  };

enum ENUM_CUSTOM_MA_METHOD
  {
   CUSTOM_SMA,     // Simple Moving Average
   CUSTOM_EMA,     // Exponential Moving Average
   CUSTOM_SMMA,    // Smoothed Moving Average
   CUSTOM_LWMA,    // Linear Weighted Moving Average
   CUSTOM_HMA,     // Hull Moving Average
   CUSTOM_ZLEMA    // Zero-Lag Exponential Moving Average
  };

//--- User Inputs
input int                   DisplayStart  = 0;       // First Fibonacci index to display
input int                   DisplayEnd    = 18;      // Last Fibonacci index to display
input ENUM_CALC_TYPE        CalcType      = CALC_NORMAL; // Calculation Mode
input ENUM_SUM_TYPE         SumType       = SUM_FORWARD; // Summation Mode
input ENUM_KD_TYPE          KDType        = KD_SIGNAL;   // Stochastic Line (%K or %D)
input int                   Slowing       = 1;       // Stochastic Slowing
input ENUM_CUSTOM_MA_METHOD MA_Method     = CUSTOM_SMA; // Moving Average Method
input ENUM_STO_PRICE        Price_Field   = STO_LOWHIGH; // Stochastic Price Field

//--- Global Variables
int      Fibonacci[] = {1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765};
int      g_buff_num = 19;

//--- Buffers
double   PlotBuffers[19][];
double   StochBuffers[19][];
int      StochHandles[19];

//--- Forward Declarations
double MA_OnArray(const double &arr[], int total, int period, ENUM_CUSTOM_MA_METHOD method, int shift);
void HMA_OnArray(const double &arr[], int total, int period, double &result_arr[]);
void ZLEMA_OnArray(const double &arr[], int total, int period, double &result_arr[]);
void CustomStochastic(int k_period, int d_period, int slowing, ENUM_CUSTOM_MA_METHOD ma_method, const int rates_total, const double &high[], const double &low[], const double &close[], double &k_buffer[], double &d_buffer[]);

//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- Check user inputs
   if(DisplayStart < 0) DisplayStart = 0;
   if(DisplayEnd >= g_buff_num) DisplayEnd = g_buff_num - 1;
   if(DisplayStart > DisplayEnd) DisplayStart = DisplayEnd;

//--- Initialize buffers
   for(int i = 0; i < g_buff_num; i++)
     {
      // Plotting buffers
      SetIndexBuffer(i, PlotBuffers[i], INDICATOR_DATA);
      ArraySetAsSeries(PlotBuffers[i], true);
      // Calculation buffers
      SetIndexBuffer(g_buff_num + i, StochBuffers[i], INDICATOR_CALCULATIONS);
      ArraySetAsSeries(StochBuffers[i], true);
     }

//--- Set up plots
   for(int i = 0; i < g_buff_num; i++)
     {
      PlotIndexSetString(i, PLOT_LABEL, "P" + (string)Fibonacci[i]);

      if(i < DisplayStart || i > DisplayEnd)
        {
         PlotIndexSetInteger(i, PLOT_DRAW_TYPE, DRAW_NONE);
         continue;
        }

      PlotIndexSetInteger(i, PLOT_DRAW_TYPE, DRAW_LINE);

      //--- Styling
      int width = 1;
      color clr;
      ENUM_LINE_STYLE style;

      // Group 1: Short-term
      if(i <= 5)
        {
         clr = color(int(50 + (i * 25)), int(50 + (i * 25)), 255); // Blue gradient
         style = STYLE_SOLID;
        }
      // Group 2: Mid-term
      else if(i <= 10)
        {
         clr = color(int(50 + ((i - 6) * 30)), 255, int(200 - ((i - 6) * 30))); // Green/Yellow gradient
         style = STYLE_DASH;
        }
      // Group 3: Long-term
      else
        {
         clr = color(255, int(200 - ((i - 11) * 25)), int(50 + ((i - 11) * 10))); // Red/Orange gradient
         style = STYLE_DOT;
        }

      // Emphasize P6, P7, P11
      if(i == 6 || i == 7 || i == 10) // Corresponds to Fib 21, 34, 144
        {
         width = 2;
        }

      PlotIndexSetInteger(i, PLOT_LINE_COLOR, clr);
      PlotIndexSetInteger(i, PLOT_LINE_STYLE, style);
      PlotIndexSetInteger(i, PLOT_LINE_WIDTH, width);
     }

//--- Initialize indicator handles for standard MAs
   for(int i = 0; i < g_buff_num; i++)
     {
      if(MA_Method < CUSTOM_HMA)
        {
         StochHandles[i] = iStochastic(Symbol(), Period(), Fibonacci[i], Fibonacci[i], Slowing, (ENUM_MA_METHOD)MA_Method, Price_Field);
        }
      else
        {
         StochHandles[i] = -1; // Custom calculation
        }
     }

   IndicatorSetString(INDICATOR_SHORTNAME, "FibStoch(" + (string)Slowing + ")");
   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//| Custom indicator iteration function                              |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const int begin,
                const double &price[])
  {
   //--- Get price data once if using custom MAs
   double high[], low[], close[];
   if(MA_Method >= CUSTOM_HMA)
     {
      if(CopyHigh(Symbol(), Period(), 0, rates_total, high) <= 0 ||
         CopyLow(Symbol(), Period(), 0, rates_total, low) <= 0 ||
         CopyClose(Symbol(), Period(), 0, rates_total, close) <= 0)
         return(0);
      ArraySetAsSeries(high, true);
      ArraySetAsSeries(low, true);
      ArraySetAsSeries(close, true);
     }

   //--- Fill stochastic buffers
   for(int i = 0; i < g_buff_num; i++)
     {
      if(MA_Method >= CUSTOM_HMA) // Custom MA calculation
        {
         double k_buffer[], d_buffer[];
         ArrayResize(k_buffer, rates_total);
         ArrayResize(d_buffer, rates_total);
         CustomStochastic(Fibonacci[i], Fibonacci[i], Slowing, MA_Method, rates_total, high, low, close, k_buffer, d_buffer);

         if(KDType == KD_MAIN)
            ArrayCopy(StochBuffers[i], k_buffer);
         else
            ArrayCopy(StochBuffers[i], d_buffer);
        }
      else // Standard MA calculation
        {
         if(StochHandles[i] == INVALID_HANDLE) continue;
         int line_type = (KDType == KD_MAIN) ? MAIN_LINE : SIGNAL_LINE;
         CopyBuffer(StochHandles[i], line_type, 0, rates_total, StochBuffers[i]);
        }
     }

   //--- Calculate plot buffers
   int limit = rates_total - prev_calculated - 1;
   if (prev_calculated==0) limit = rates_total - 1;

   for(int bar = limit; bar >= 0; bar--)
     {
      for(int i = DisplayStart; i <= DisplayEnd; i++)
        {
         double val = 0;
         double stoch_val = StochBuffers[i][bar];
         if(stoch_val <= 0 || stoch_val >= 100)
           {
            PlotBuffers[i][bar] = 0;
            continue;
           }

         // --- Select calculation type ---
         switch(CalcType)
           {
            case CALC_NORMAL:
               PlotBuffers[i][bar] = stoch_val;
               break;

            case CALC_SUM:
               double sum = 0;
               double count = 0;
               if(SumType == SUM_FORWARD)
                 {
                  for(int j = i; j <= DisplayEnd; j++)
                    {
                     sum += StochBuffers[j][bar];
                     count++;
                    }
                 }
               else // SUM_BACKWARD
                 {
                  for(int j = DisplayStart; j <= i; j++)
                    {
                     sum += StochBuffers[j][bar];
                     count++;
                    }
                 }
               PlotBuffers[i][bar] = (count > 0) ? sum / count : 0;
               break;

            case CALC_DIV:
               if(bar > 0)
                  PlotBuffers[i][bar] = stoch_val - StochBuffers[i][bar + 1];
               break;

            case CALC_SIGN:
               if(bar > 0)
                  PlotBuffers[i][bar] = (stoch_val > StochBuffers[i][bar + 1]) ? 100 : ((stoch_val < StochBuffers[i][bar + 1]) ? 0 : 50);
               break;

            case CALC_DIV_SUM:
               double div_sum = 0;
               if(bar > 0)
                 {
                  for(int j = i; j <= DisplayEnd; j++)
                    {
                     div_sum += StochBuffers[j][bar] - StochBuffers[j][bar + 1];
                    }
                 }
               PlotBuffers[i][bar] = div_sum;
               break;

            case CALC_MULT:
               double mult = 1.0;
               for(int j = i; j <= DisplayEnd; j++)
                 {
                  mult *= StochBuffers[j][bar] / 50.0;
                 }
               PlotBuffers[i][bar] = 50.0 + (50.0 * MathLog10(mult));
               break;
           }
        }
     }
   return(rates_total);
  }
//+------------------------------------------------------------------+
//| Custom MA Implementations                                        |
//+------------------------------------------------------------------+
// Generic MA on Array
double MA_OnArray(const double &arr[], int total, int period, ENUM_CUSTOM_MA_METHOD method, int shift)
  {
   double sum = 0;
   switch(method)
     {
      case CUSTOM_SMA:
      case CUSTOM_SMMA: // Simplified SMMA for this context
         if(period <= 0 || shift >= total - period) return 0;
         for(int i = 0; i < period; i++) sum += arr[shift + i];
         return sum / period;
      case CUSTOM_EMA:
         // Not fully implemented to avoid complexity, SMA is used as fallback
         if(period <= 0 || shift >= total - period) return 0;
         for(int i = 0; i < period; i++) sum += arr[shift + i];
         return sum / period;
      case CUSTOM_LWMA:
         if(period <= 0 || shift >= total - period) return 0;
         double lwma_sum = 0;
         int weight_sum = 0;
         for(int i = 0; i < period; i++)
           {
            lwma_sum += arr[shift + i] * (period - i);
            weight_sum += (period - i);
           }
         return (weight_sum > 0) ? lwma_sum / weight_sum : 0;
     }
   return 0;
  }

// HMA on Array
void HMA_OnArray(const double &arr[], int total, int period, double &result_arr[])
  {
   if(period <= 1) return;
   int half_period = period / 2;
   int sqrt_period = (int)MathSqrt(period);
   double wma_half[], wma_full[], temp_arr[];
   ArrayResize(wma_half, total);
   ArrayResize(wma_full, total);
   ArrayResize(temp_arr, total);

   for(int i = 0; i < total; i++)
     {
      wma_half[i] = MA_OnArray(arr, total, half_period, CUSTOM_LWMA, i);
      wma_full[i] = MA_OnArray(arr, total, period, CUSTOM_LWMA, i);
      temp_arr[i] = 2.0 * wma_half[i] - wma_full[i];
     }
   for(int i = 0; i < total; i++)
     {
      result_arr[i] = MA_OnArray(temp_arr, total, sqrt_period, CUSTOM_LWMA, i);
     }
  }

// ZLEMA on Array
void ZLEMA_OnArray(const double &arr[], int total, int period, double &result_arr[])
  {
   if(period <= 0) return;
   int lag = (period - 1) / 2;
   double ema_arr[];
   ArrayResize(ema_arr, total);

   // Simplified EMA for ZLEMA
   double alpha = 2.0 / (period + 1.0);
   ema_arr[total-1] = arr[total-1];
   for(int i = total - 2; i >= 0; i--)
     {
      ema_arr[i] = arr[i] * alpha + ema_arr[i+1] * (1.0 - alpha);
     }

   for(int i = 0; i < total - lag; i++)
     {
      result_arr[i] = ema_arr[i] + (arr[i] - ema_arr[i + lag]);
     }
  }

//+------------------------------------------------------------------+
//| Custom Stochastic Calculation                                    |
//+------------------------------------------------------------------+
void CustomStochastic(int k_period, int d_period, int slowing, ENUM_CUSTOM_MA_METHOD ma_method,
                      const int rates_total, const double &high[], const double &low[], const double &close[],
                      double &k_buffer[], double &d_buffer[])
  {
   if(k_period <= 0 || d_period <= 0) return;
   double stoch_val[];
   ArrayResize(stoch_val, rates_total);

   for(int i = 0; i < rates_total - k_period; i++)
     {
      double hh = high[ArrayMaximum(high, i, k_period)];
      double ll = low[ArrayMinimum(low, i, k_period)];
      double den = hh - ll;
      stoch_val[i] = (den != 0) ? 100.0 * (close[i] - ll) / den : 0;
     }

   // Slowing
   if(slowing > 1)
     {
      double temp_k[];
      ArrayResize(temp_k, rates_total);
      for(int i=0; i<rates_total; i++)
        {
         temp_k[i] = MA_OnArray(stoch_val, rates_total, slowing, CUSTOM_SMA, i);
        }
      ArrayCopy(k_buffer, temp_k);
     }
   else
     {
      ArrayCopy(k_buffer, stoch_val);
     }

   // %D Line
   if(ma_method == CUSTOM_HMA)
      HMA_OnArray(k_buffer, rates_total, d_period, d_buffer);
   else if(ma_method == CUSTOM_ZLEMA)
      ZLEMA_OnArray(k_buffer, rates_total, d_period, d_buffer);
   else
     {
      for(int i=0; i<rates_total; i++)
        {
         d_buffer[i] = MA_OnArray(k_buffer, rates_total, d_period, ma_method, i);
        }
     }
  }
//+------------------------------------------------------------------+